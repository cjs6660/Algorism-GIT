# swea 1-2일차

**1일차 min max**

---

N개의 양의 정수에서 가장 큰 수와 가장 작은 수의 차이를 출력하시오.

[입력] 첫 줄에 테스트 케이스의 수 T가 주어진다. ( 1 ≤ T ≤ 50 ) 각 케이스의 첫 줄에 양수의 개수 N이 주어진다. ( 5 ≤ N ≤ 1000 ) 다음 줄에 N개의 양수 ai가 주어진다. ( 1 ≤ ai≤ 1000000 )

[출력] 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

```python
T = int(input())

for i in range(1, T + 1):
    input() 

    j = list(map(int, input().split(" "))) 
    result = max(j) - min(j)
    
    print(f"#{i} {result}")
```



**1일차 숫자카드**

---

0에서 9까지 숫자가 적힌 N장의 카드가 주어진다.
가장 많은 카드에 적힌 숫자와 카드가 몇 장인지 출력하는 프로그램을 만드시오. 카드 장수가 같을 때는 적힌 숫자가 큰 쪽을 출력한다.

[입력]
첫 줄에 테스트 케이스 개수 T가 주어진다.  ( 1 ≤ T ≤ 50 )
다음 줄부터 테스트케이스의 첫 줄에 카드 장수 N이 주어진다. ( 5 ≤ N ≤ 100 )
다음 줄에 N개의 숫자 ai가 여백없이 주어진다. (0으로 시작할 수도 있다.)  ( 0 ≤ ai ≤ 9 ) 

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 가장 많은 카드의 숫자와 장 수를 차례로 출력한다

```python
T = int(input())

for testcase in range(1, T + 1): 
    N = int(input()) #입력받을 카드의 개수
    nums = input() #입력받은 카드들
    cards = [0 for i in range(10)]
    for i in range(N): #입력받은 카드의 개수만큼 반복
        cards[int(nums[i])] += 1 #카드번호를 인덱스로 취급해서 cards의 인덱스 위치의 값을 1씩 증가시켜줌
    
    result_count = max(cards) #cards에 저장된 가장 큰 값을 출력
    
    for i in range(10):
        if cards[i] == result_count:
            result = i #같은 result_count 중에 가장 큰 숫자의 카드번호를 출력
    print(f"#{testcase} {result} {result_count}")
```

**1일차 구간합**

---

N개의 정수가 들어있는 배열에서 이웃한 M개의 합을 계산하는 것은 디지털 필터링의 기초연산이다.
M개의 합이 가장 큰 경우와 가장 작은 경우의 차이를 출력하는 프로그램을 작성하시오.
다음은 N=5, M=3이고 5개의 숫자 1 2 3 4 5가 배열 v에 들어있는 경우이다.

이웃한 M개의 합이 가장 작은 경우 1 + 2 + 3 = 6
이웃한 M개의 합이 가장 큰 경우 3 + 4 + 5 = 12
답은 12와 6의 차인 6을 출력한다.

[입력]
첫 줄에 테스트 케이스 개수 T가 주어진다.  ( 1 ≤ T ≤ 50 )
다음 줄부터 테스트케이스의 첫 줄에 정수의 개수 N과 구간의 개수 M 주어진다. ( 10 ≤ N ≤ 100,  2 ≤ M ＜ N )
다음 줄에 N개의 정수 ai가 주어진다. ( 1 ≤ a ≤ 10000 )

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

```python
T = int(input())

for testcase in range(1, T + 1): 
    N, M = map(int, input().split()) #N개의 정수와 M개의 합
    nums = list(map(int, input().split())) #숫자 리스트
    sums = [] #M개의 합 받아주기
    
    for i in range(N-M+1): #마지막 구간의 첫 인덱스 구하기
        sums.append(sum(nums[i:i+M])) #sum 배열에 각 구간의 합을 넣기
        
    print(f'#{testcase} {max(sums) - min(sums)}') #차를 구해야하므로 max-min
```

**2일차 색칠하기**

---

[입력] 첫 줄에 테스트 케이스 개수 T가 주어진다. ( 1 ≤ T ≤ 50 ) 다음 줄부터 테스트케이스의 첫 줄에 칠할 영역의 개수 N이 주어진다. ( 2 ≤ N ≤ 30 ) 다음 줄에 왼쪽 위 모서리 인덱스 r1, c1, 오른쪽 아래 모서리 r2, c2와 색상 정보 color가 주어진다. ( 0 ≤ r1, c1, r2, c2 ≤ 9 ) color = 1 (빨강), color = 2 (파랑)

[출력] 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

```py
T = int(input())

for testcase in range(1, T+1):
    N = int(input())    #색칠할 영역개수
    arr = [[0]*10 for i in range(10)] #10x10배열
    
    for i in range(N):
        x1, y1, x2, y2, color = map(int, input().split()) #좌표와 color 받기
        
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
                if arr[i][j] == 0:   #아무것도 안칠해져있으면 0
                    arr[i][j] = color
                elif arr[i][j] != color: #현재컬러와 이미 칠해져있는 색이 다를 경우 
                    arr[i][j] = 3   #섞인 색을 3으로 받아주기
                
    purple = 0 #보라색 구하기
    for i in range(10):
        for j in range(10):
            if arr[i][j] == 3:
                purple += 1 #purple 개수 세어주기
    print(f'#{testcase} {purple}')
```